# 十四、贪心算法

## 14.1 贪心算法

### 买卖股票的最佳时机 ⭐️⭐️

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

**示例**

- 输入：[7,1,5,3,6,4]
- 输出：5
- 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6,
  因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

**思路**

- 遍历过程中，每个元素减去前面出现过的最小值，求这个差值的最大值即可。

**代码**

```java
class Solution {
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int ans = Integer.MIN_VALUE;
        for (int i = 0; i < prices.length; i++) {
            ans = Math.max(ans, prices[i] - min);
            min = Math.min(min, prices[i]);
        }
        return Math.max(ans, 0);
    }
}
```

### 买卖股票的最佳时机 II ⭐️⭐️

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

**示例**

- 输入：prices = [7,1,5,3,6,4]
- 输出：7
- 解释：
    - 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
    - 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
    - 最大总利润为 4 + 3 = 7 。

**思路**

- 因为交易次数无限，所以选择所有有收益的相邻日间进行交易，可得利润最大化。

**代码**

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        for (int i = 1; i < prices.length; i++) {
            ans += Math.max(0, prices[i] - prices[i - 1]);
        }
        return ans;
    }
}
```

### 跳跃游戏 ⭐️⭐️

给你一个非负整数数组 `nums` ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

**示例**

- 输入：nums = [2,3,1,1,4]
- 输出：true
- 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

**思路**

- 维护一个最远可达距离 `rightmost`。遍历数组，如果当前下标超过当前最远可达距离，直接返回不可到达。
- 如果最远可达距离超过了数组右边界，则可以到达。

**代码**

```java
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int rightmost = 0;
        for (int i = 0; i < n; i++) {
            if (i > rightmost) {
                return false;
            }
            rightmost = Math.max(rightmost, i + nums[i]);
            if (rightmost >= n - 1) {
                return true;
            }
        }
        return false;
    }
}
```

### 跳跃游戏 II ⭐️⭐️⭐️

给定一个长度为 `n` 的 `0` 索引整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

`0 <= j <= nums[i]`
`i + j < n`
返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

**示例**

- 输入: nums = [2,3,1,1,4]
- 输出: 2
- 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

**思路**

- 最远可达距离 `rightmost` 表示当前可以到达的最远距离。
- 最远跳跃范围 `end` 表示在当前步数下可以到达的最远距离。
- 如果遍历到 `end`，表明需要增加新的步数，并扩展 `end` 为 `rightmost`。
- 无需考虑最后一个元素。

**代码**

```java
class Solution {
    public int jump(int[] nums) {
        int length = nums.length;
        int end = 0;
        int rightmost = 0;
        int ans = 0;
        for (int i = 0; i < length - 1; i++) {
            rightmost = Math.max(rightmost, i + nums[i]);
            if (i == end) {
                end = rightmost;
                ans++;
            }
        }
        return ans;
    }
}
```

### 根据身高重建队列 ️⭐️️⭐️️⭐️

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]`
表示第 `i` 个人的身高为 `hi` ，前面 正好 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]`
是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

**示例**

- 输入：people = \[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
- 输出：\[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
- 解释：
    - 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
    - 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
    - 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
    - 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
    - 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
    - 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
    - 因此 \[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

**思路**

- 将数组按照身高降序、前面人数升序排序。优先考虑个子高的人，个子相同则考虑前面人数少的人。
- 依次插入队列，将当前人插入到**当前前面人数等于 `ki` 的位置**。

**代码**

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 按照身高降序，k值升序排序
        Arrays.sort(people, (a, b) -> {
            if (a[0] != b[0]) {
                return b[0] - a[0];
            }
            return a[1] - b[1];

        });
        // 插入到队列中
        List<int[]> ans = new ArrayList<>();
        for (int[] person : people) {
            // 在当前下标插入这个人
            ans.add(person[1], person);
        }
        return ans.toArray(new int[0][]);
    }
}
```

### 加油站 ⭐️⭐️⭐️

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证
它是 唯一 的。

**示例**

- 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
- 输出: 3
- 解释:
    - 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
    - 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
    - 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
    - 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
    - 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
    - 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
    - 因此，3 可为起始索引。

**思路**

- 总油量检查：
    - 计算总的汽油量和总的消耗量。
    - 如果总汽油量小于总消耗量，则不可能绕环路一周，返回 -1。
- 寻找起点：
    - 如果总汽油量大于或等于总消耗量，则存在一个有效的起点。
    - 从第一个加油站开始，逐步检查每个加油站是否能成为有效的起点。
    - 使用一个变量来跟踪当前油量，并用另一个变量来记录起点。若在某个点油量变成负值，则该起点不可行，需将起点移动到下一个加油站，并重置当前油量。

**代码**

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        int totalGas = 0;
        int totalCost = 0;
        for (int i = 0; i < n; i++) {
            totalGas += gas[i];
            totalCost += cost[i];
        }
        if (totalGas < totalCost) {
            return -1;
        }
        // 寻找起点
        int cur = 0;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            cur += gas[i] - cost[i];
            // 如果当前剩余油量为负，更换为下一个起点
            if (cur < 0) {
                ans = i + 1;
                cur = 0;
            }
        }
        return ans;
    }
}
```

### 分发糖果 ⭐️⭐️⭐️⭐️

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 1 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。
  请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

**示例**

- 输入：ratings = [1,0,2]
- 输出：5
- 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。

**思路**

- 两次遍历。初始所有孩子为 1 个糖果。
- 从左到右遍历。如果每个孩子的评分比左边孩子高，则可以比左边孩子多拿一颗糖果。
- 从右到左遍历。如果每个孩子的评分比右边孩子高，则可以比右边孩子多拿一颗糖果。取这两种方案的最大值作为最终方案。

**代码**

```java
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int[] candies = new int[n];
        // 每个孩子至少有一个糖果
        Arrays.fill(candies, 1);
        // 从左到右遍历
        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i - 1]) {
                candies[i] = candies[i - 1] + 1;
            }
        }
        // 从右到左遍历
        for (int i = n - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) {
                candies[i] = Math.max(candies[i], candies[i + 1] + 1);
            }
        }
        // 计算总糖果数
        int ans = 0;
        for (int candy : candies) {
            ans += candy;
        }
        return ans;
    }
}
```
