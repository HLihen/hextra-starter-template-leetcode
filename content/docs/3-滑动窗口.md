# 三、滑动窗口
## 3.1 固定长度窗口
### 找到字符串中所有字母异位词 ⭐️⭐️
给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

异位词指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例**
- 输入: s = "cbaebabacd", p = "abc"
- 输出: [0,6]
- 解释: 
    - 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
    - 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

**思路**
- 设定长度为 `p.length` 的滑动窗口。
- 通过比较窗口中所有字符的个数与字符串 `p` 中对应字符的个数是否相等筛选出异位词。
- 使用数组统计字符个数。
- 在滑动窗口右滑的过程中对新访问的字符数量++，对滑走的字符数量--。

**代码**
```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int n = s.length();
        int m = p.length();

        int[] sCount = new int[26];
        int[] pCount = new int[26];
        List<Integer> ans = new ArrayList<>();

        for (int i = 0; i < m; i++) {
            pCount[p.charAt(i) - 'a']++;
        }
        int right = 0;
        while (right < n) {
            sCount[s.charAt(right) - 'a']++;
            int left = right - m + 1;
            // 表明滑动窗口开始滑动
            if (left > 0) {
                sCount[s.charAt(left - 1) - 'a']--;
            }
            // 表明符合滑动窗口大小
            if (left >= 0) {
                if (Arrays.equals(sCount, pCount)) {
                    ans.add(left);
                }
            }
            right++;
        }
        return ans;
    }
}
```

### 找到 K 个最接近的元素 ⭐️⭐️
给定一个 排序好 的数组 `arr` ，两个整数 `k` 和 `x` ，从数组中找到最靠近 `x`（两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。

整数 `a` 比整数 `b` 更接近 `x` 需要满足：

`|a - x| < |b - x|` 或者
`|a - x| == |b - x|` 且 `a < b`

**示例**
- 输入：arr = [1,2,3,4,5], k = 4, x = 3
- 输出：[1,2,3,4]

**思路**
- 因为是有序的，所以这些数是连续的，因此可以用滑动窗口来做。
- 求使得窗口内所有元素与 `x` 距离之和最小的窗口范围即可。

**代码**
```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int n = arr.length;
        int right = 0;
        int sum = 0;
        int minSum = Integer.MAX_VALUE;
        int res = 0;
        while (right < n) {
            sum += Math.abs(arr[right] - x);
            int left = right - k + 1;
            if (left > 0) {
                sum -= Math.abs(arr[left - 1] - x);
            }
            if (left >= 0) {
                if (sum < minSum) {
                    res = left;
                    minSum = sum;
                }
            }
            right++;
        }
        List<Integer> ans = new ArrayList<>();
        for (int i = res; i < res + k; i++) {
            ans.add(arr[i]);
        }
        return ans;
    }
}
```

### 重复的DNA序列 ⭐️⭐️
DNA序列 由一系列核苷酸组成，缩写为 `'A', 'C', 'G'` 和 `'T'`.。

例如，`"ACGAATTCCG"` 是一个 DNA序列 。
在研究 DNA 时，识别 DNA 中的重复序列非常有用。

给定一个表示 DNA序列 的字符串 `s` ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。

**示例**
- 输入：s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
- 输出：["AAAAACCCCC","CCCCCAAAAA"]

**思路**
- 滑动窗口，维护窗口中构成的字符串，并用集合判断重复。
- 也可以直接用 `substring()`

**代码**
```java
class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        Set<String> set = new HashSet<>();
        Set<String> ans = new HashSet<>();
        StringBuilder sb = new StringBuilder();
        int right = 0;
        while (right < s.length()) {
            sb.append(s.charAt(right));
            int left = right - 9;
            if (left > 0) {
                sb.deleteCharAt(0);
            }
            if (left >= 0) {
                String str = sb.toString();
                if (set.contains(str)) {
                    ans.add(str);
                } else {
                    set.add(str);
                }
            }
            right++;
        }
        return ans.stream().toList();
    }
}
```

### 滑动窗口最大值 ⭐️⭐️⭐️
给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

**示例**
- 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
- 输出：[3,3,5,5,6,7]

**思路**
- 使用双向队列。
- 窗口右边界向右滑动时先弹出队列末尾所有<=新元素，然后末尾加入新元素。
- 判断队头元素是否还在窗口中，如果不在则弹出。
- 队头元素即为窗口中的最大值。

**代码**
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>();

        int right = 0;
        while(right < n) {
            int left = right - k + 1;
            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[right]) {
                deque.pollLast();
            }
            deque.offerLast(right);
            if (!deque.isEmpty() && deque.peekFirst() < left) {
                deque.pollFirst();
            }
            if (left >= 0) {
                ans[left] = nums[deque.peekFirst()];
            }
            right++;
        }
        return ans;
    }
}
```
### 串联所有单词的子串 ⭐️⭐️⭐️⭐️
给定一个字符串 `s` 和一个字符串数组 `words`。 `words` 中所有字符串 长度相同。

`s` 中的 串联子串 是指一个包含  `words` 中所有字符串以任意顺序排列连接起来的子串。

- 例如，如果 words = `["ab","cd","ef"]`， 那么 `"abcdef"`， `"abefcd"`，`"cdabef"`， `"cdefab"`，`"efabcd"`， 和 `"efcdab"` 都是串联子串。 `"acdbef"` 不是串联子串，因为他不是任何 `words` 排列的连接。

返回所有串联子串在 `s` 中的开始索引。你可以以 任意顺序 返回答案。

**示例**
- 输入：s = "barfoothefoobarman", words = ["foo","bar"]
- 输出：[0,9]
- 解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。

**思路**
- 与**找到字符串中所有字母异位词**类似。遍历的单元从字符变为字符串。
- 需要找到开始遍历的位置。取 `words` 中所有模式串（长度为 `m`）在主串 `s` 中出现的下标的最小值作为最小开始位置 `init`，取区间 `[init, init + m)` 作为开始位置 `start`。
- 初始窗口位于 `start`，然后按照窗口大小为 `m * word.length`，步长为 `m` 的滑动窗口算法进行匹配。

**代码**
```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        int n = s.length();
        int m = words[0].length();
        List<Integer> ans = new ArrayList<>();

        // 统计单词出现的次数
        Map<String, Integer> wordCount = new HashMap<>();
        // 找开始的地方
        int init = n;
        for (String word : words) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
            int index = s.indexOf(word);
            if (index >= 0) {
                init = Math.min(init, index);
            }
        }
        // 枚举开始位置
        for (int start = init; start < init + m; start++) {
            int right = start;

            Map<String, Integer> seen = new HashMap<>();
            while (right + m <= n) {
                // 增加单词次数
                String str = s.substring(right, right + m);
                seen.put(str, seen.getOrDefault(str, 0) + 1);
                int left = right - m * words.length + m;
                // 表明滑动窗口开始滑动
                if (left > start) {
                    // 减少单词次数
                    str = s.substring(left - m, left);
                    seen.put(str, seen.get(str) - 1);
                    if (seen.get(str) == 0) {
                        seen.remove(str);
                    }
                }
                // 表明符合滑动窗口大小
                if (left >= start) {
                    if (seen.equals(wordCount)) {
                        ans.add(left);
                    }
                }
                right += m;
            }
        }
        return ans;
    }
}
```

## 3.2 最小窗口
初始窗口位于第一个元素。如果窗口不满足条件，则右界向右扩展；满足条件则左界向右收缩，并记录此时的窗口大小。直到窗口右界出界。
```java
while(right < n){
    if(窗口不满足条件){
        right++;
        ...
    }else{
        // 此时窗口满足条件
        ans = Math.min(ans, right - left + 1);
        left++;
    }
}
```
### 长度最小的子数组 ⭐️⭐️
给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。

找出该数组中满足其总和大于等于 `target` 的长度最小的 
子数组
 `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回 `0` 。

**示例**
- 输入：target = 7, nums = [2,3,1,2,4,3]
- 输出：2
- 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

**思路**
- 最小窗口问题。

**代码**
```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int left = 0;
        int right = 0;
        int sum = nums[0];
        int ans = n + 1;

        while (right < n) {
            if (sum < target) {
                right++;
                if (right < n) {
                    sum += nums[right];
                }
            } else {
                ans = Math.min(ans, right - left + 1);
                sum -= nums[left];
                left++;
            }
        }
        return ans == n + 1 ? 0 : ans;
    }
}
```
### 最小覆盖子串 ⭐️⭐️⭐️
给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 "" 。

注意：

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例**
- 输入：s = "ADOBECODEBANC", t = "ABC"
- 输出："BANC"
- 解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

**思路**
- 这道题需要动态改变滑动窗口的大小。
- 初始化滑动窗口为 `[0,0]`。如果窗口符合要求，则扩展右边界，如果不符合要求，则缩小左边界。
- 使用数组维护 `s` 和 `t` 中各字符出现的次数。要求 `s` 中各字符出现的次数均不小于 `t` 中各字符出现的次数。

**代码**
```java
class Solution {
    public boolean check(int[] sArray, int[] tArray) {
        for (int i = 0; i < sArray.length; i++) {
            if (sArray[i] < tArray[i]) {
                return false;
            }
        }
        return true;
    }

    public String minWindow(String s, String t) {
        int n = s.length();
        int[] sArray = new int[80];
        int[] tArray = new int[80];

        for (char c : t.toCharArray()) {
            tArray[c - 'A']++;
        }
        int left = 0;
        int right = 0;
        int[] ans = new int[]{0, Integer.MAX_VALUE};

        sArray[s.charAt(0) - 'A'] = 1;
        while (right < n) {
            if (check(sArray, tArray)) {
                if (right - left < ans[1] - ans[0]) {
                    ans = new int[]{left, right};
                }
                // 左侧次数-1
                sArray[s.charAt(left) - 'A']--;
                left++;
            } else {
                // 右侧次数+1
                right++;
                if (right < n) {
                    sArray[s.charAt(right) - 'A']++;
                }
            }
        }
        if (ans[1] == Integer.MAX_VALUE) {
            return "";
        }
        return s.substring(ans[0], ans[1] + 1);
    }
}
```

## 3.3 最大窗口
初始窗口位于第一个元素。窗口右界不断向右扩展，直到出界或窗口不满足条件，并记录此时的窗口大小。然后左界向右收缩，直到窗口左界出界。
```java
while(left < n){
    while(right < n && 窗口满足条件){
        right++;
    }
    // 此时窗口已不满足条件
    ans = Math.max(ans, right - left);
    left++;
}
```
### 无重复字符的最大子串 ⭐️⭐️
给定一个字符串 `s` ，请你找出其中不含有重复字符的最长子串的长度。

**示例**
- 输入: s = "abcabcbb"
- 输出: 3 
- 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

**思路**
- 设定左右指针
- 右指针从头向右遍历，并将元素加入集合，直到集合中出现重复元素。
- 左指针向右移动，并且从集合中删掉移走的元素。
- 直到**左指针**碰到数组末尾，结束循环。

**代码**
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int ans = 0;
        int left = 0;
        int right = 0;
        while (left < s.length()) {
            while (right < s.length() && !set.contains(s.charAt(right))) {
                set.add(s.charAt(right));
                right++;
            }
            ans = Math.max(ans, right - left);
            set.remove(s.charAt(left));
            left++;
        }
        return ans;
    }
}
```







