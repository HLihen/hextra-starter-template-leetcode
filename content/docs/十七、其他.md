# 十七、其他

## 17.1 模拟

### 坐上公交的最晚时间 ⭐️⭐️⭐️

给你一个下标从 `0` 开始长度为 `n` 的整数数组 `buses` ，其中 `buses[i]` 表示第 `i`
辆公交车的出发时间。同时给你一个下标从 `0` 开始长度为
`m` 的整数数组 `passengers` ，其中 `passengers[j]` 表示第 `j` 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。

给你一个整数 `capacity` ，表示每辆公交车 最多 能容纳的乘客数目。

每位乘客都会搭乘下一辆有座位的公交车。如果你在 `y` 时刻到达，公交在 `x` 时刻出发，满足 `y <= x` 且公交没有满，那么你可以搭乘这一辆公交。最早
到达的乘客优先上车。

返回你可以搭乘公交车的最晚到达公交站时间。你 不能 跟别的乘客同时刻到达。

注意：数组 `buses` 和 `passenger`s 不一定是有序的。

**示例**

- 输入：buses = [10,20], passengers = [2,17,18,19], capacity = 2
- 输出：16
- 解释：
  第 1 辆公交车载着第 1 位乘客。
  第 2 辆公交车载着你和第 2 位乘客。
  注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。

**思路**

- 遍历每辆公交车，模拟乘客上车。
- 模拟结束，如果最后一辆公交车还有空位，则最晚不得晚于公交车到达（发车）时间；如果没有空位，则最晚不得晚于最后一名乘客到达时间。
- 到达时间向前遍历，找到第一个没有其他乘客到达的时间作为答案。

**代码**

```java
class Solution {
    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {
        Arrays.sort(buses);
        Arrays.sort(passengers);
        // 乘客下标
        int k = 0;
        int space = 0;
        for (int arrive : buses) {
            space = capacity;
            while (space > 0 && k < passengers.length && passengers[k] <= arrive) {
                space--;
                k++;
            }
        }
        k--;
        // 还有空位则为最后一辆公交车到达时间，否则为最后一名乘客到达时间
        int lastCatchTime = space > 0 ? buses[buses.length - 1] : passengers[k];
        // 向前找第一个没有乘客重合的时间
        while (k >= 0 && passengers[k] == lastCatchTime) {
            k--;
            lastCatchTime--;
        }
        return lastCatchTime;
    }
}
```
