# 十七、其他

## 17.1 模拟

### 坐上公交的最晚时间 ⭐️⭐️⭐️

给你一个下标从 `0` 开始长度为 `n` 的整数数组 `buses` ，其中 `buses[i]` 表示第 `i`
辆公交车的出发时间。同时给你一个下标从 `0` 开始长度为
`m` 的整数数组 `passengers` ，其中 `passengers[j]` 表示第 `j` 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。

给你一个整数 `capacity` ，表示每辆公交车 最多 能容纳的乘客数目。

每位乘客都会搭乘下一辆有座位的公交车。如果你在 `y` 时刻到达，公交在 `x` 时刻出发，满足 `y <= x` 且公交没有满，那么你可以搭乘这一辆公交。最早
到达的乘客优先上车。

返回你可以搭乘公交车的最晚到达公交站时间。你 不能 跟别的乘客同时刻到达。

注意：数组 `buses` 和 `passenger`s 不一定是有序的。

**示例**

- 输入：buses = [10,20], passengers = [2,17,18,19], capacity = 2
- 输出：16
- 解释：
  第 1 辆公交车载着第 1 位乘客。
  第 2 辆公交车载着你和第 2 位乘客。
  注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。

**思路**

- 遍历每辆公交车，模拟乘客上车。
- 模拟结束，如果最后一辆公交车还有空位，则最晚不得晚于公交车到达（发车）时间；如果没有空位，则最晚不得晚于最后一名乘客到达时间。
- 到达时间向前遍历，找到第一个没有其他乘客到达的时间作为答案。

**代码**

```java
class Solution {
    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {
        Arrays.sort(buses);
        Arrays.sort(passengers);
        // 乘客下标
        int k = 0;
        int space = 0;
        for (int arrive : buses) {
            space = capacity;
            while (space > 0 && k < passengers.length && passengers[k] <= arrive) {
                space--;
                k++;
            }
        }
        k--;
        // 还有空位则为最后一辆公交车到达时间，否则为最后一名乘客到达时间
        int lastCatchTime = space > 0 ? buses[buses.length - 1] : passengers[k];
        // 向前找第一个没有乘客重合的时间
        while (k >= 0 && passengers[k] == lastCatchTime) {
            k--;
            lastCatchTime--;
        }
        return lastCatchTime;
    }
}
```

## 17.2 特殊思路

### 找出第 K 个字符 II ⭐️⭐⭐⭐

Alice 和 Bob 正在玩一个游戏。最初，Alice 有一个字符串 `word = "a"`。

给定一个正整数 `k` 和一个整数数组 `operations`，其中 `operations[i]` 表示第 `i` 次操作的类型。

现在 `Bob` 将要求 `Alice` 按顺序执行 所有 操作：

- 如果 `operations[i] == 0`，将 `word` 的一份 副本追加 到它自身。
- 如果 `operations[i] == 1`，将 `word` 中的每个字符 更改 为英文字母表中的 下一个 字符来生成一个新字符串，并将其 追加 到原始的
  `word`。例如，对 `c` 进行操作生成 `cd`，对 `zb` 进行操作生成 `zbac`。
  在执行所有操作后，返回 `word` 中第 `k` 个字符的值。

注意，在第二种类型的操作中，字符 `z` 可以变成 `a`。

**示例**

- 输入：k = 10, operations = [0,1,0,1]
- 输出："b"
- 解释： 最初，word == "a"。Alice 按以下方式执行四次操作：
    - 将 "a" 附加到 "a"，word 变为 "aa"。
    - 将 "bb" 附加到 "aa"，word 变为 "aabb"。
    - 将 "aabb" 附加到 "aabb"，word 变为 "aabbaabb"。
    - 将 "bbccbbcc" 附加到 "aabbaabb"，word 变为 "aabbaabbbbccbbcc"。

**思路**

- 注意到需要的绝对下标 `k` 可以表示为 `2 ^ index + offset` 的形式，其中 `index` 为操作的下标，`offset`
  为该字符在该次操作下生成的新字符串中的相对下标。
- 子节点的 `offset` 对应父节点的 `k`，向前回溯到根节点（即 `k == 0` ）。
- 在回溯过程中根据每次计算出的操作 `index`，如果 `operation[index]` 为 1 则将初始字符 `a` 循环加一即可得出最终子节点的字符。

**代码**

```java
class Solution {
    // 计算 index 和 offset
    long[] getIndexAndOffset(long k) {
        int index = -1;
        long temp = k;
        while (temp > 0) {
            temp /= 2;
            index++;
        }
        return new long[]{index, k - (1L << index)};
    }

    public char kthCharacter(long k, int[] operations) {
        char c = 'a';
        k--;
        while (k > 0) {
            long[] indexAndOffset = getIndexAndOffset(k);
            long index = indexAndOffset[0];
            if (index >= 0 && operations[(int) index] == 1) {
                c = c == 'z' ? 'a' : (char) (c + 1);
            }
            // offset 作为下一轮的绝对下标
            k = indexAndOffset[1];
        }
        return c;
    }
}
```
